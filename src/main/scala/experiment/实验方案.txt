1、数据来源：http://snap.stanford.edu/data/index.html
  先选择无向图来做
  (1)输入的可能是 (点，点)，这个时候会默认转化为(点，点，1)，也可能是(点，点，weight)，需要改一下代码
  (2)需要检查一些文件是否存储无向边
  输入可能是txt文件，但是我之前用的是CSV文件，要么改一下代码，要么用python转化为CSV

2、K-L算法 (1) 实验一下不同初始化子图情况下，performance的变化，更换seed
          (2) 画一下实验过程中，performance的变化曲线，逐渐增大，证明这个贪心策略有效
           结论：
           (1) K-L对初始图划分很敏感
           (2)performance逐渐变大，每次交换都会使图划分的质量变好，贪心策略有效
seed=324 performance 变化
         1.058180167977191 1.2043439605287887 1.3857470115576542 1.6414952825614086 1.8884837024059846 2.1858550277927074 2.4998987346812274 2.9139041578091276 3.421186915673112 3.7061394576560365 4.122946802750419 4.466533447840158 4.822989591659194 5.105654060668106 5.57744308108092 6.040302987751118 6.445189455956674 6.822098508845271 7.2201953529020875 7.663005053835536 8.088485093571123 8.492392429712359 8.879553998096648 9.106562809291043 9.223918084863977 9.29499823449458 9.328204819416628 9.353000586441842
         图分割的performance为: 9.353000586441842
         运行时间=216.458

seed=3241 performance 变化
         1.1379263305081786 1.3285334570087808 1.5474902385825238 1.8077571866870923 2.183483896900897 2.5390070955332926 2.8978145662531944 3.2252179579346194 3.5331286485999227 3.8731254789037246 4.286088983010702 4.668554671825628 5.069907695635917 5.374745628709199 5.749359063817297 6.09480563672934 6.686232588151165 7.484239055614149 8.0496420401256 8.822177572743463 9.544516155954804 10.163632668083924 10.570976477752826 10.946441400156239 11.280684040658556 11.466396736334918 11.596027730945345 11.619001054402
         运行时间=201.405
         图分割的performance为: 11.619001054402

seed=1234        performance 变化
         0.9460881935073671 1.025939674781542 1.1100092154359065 1.2307312000851487 1.3697025938183636 1.550659397042052 1.6849572024259027 1.8254371620288377 1.9300592037806457 2.0255012756982413 2.182600509222245 2.3969511084244397 2.652235544186077 3.071271710803448 3.6655707303114387 4.533839570438643 5.5490767268164864 6.634723806620023 8.080336113669096 9.694921511594943 11.413897673955923 13.59612588724375 15.094847509401106 16.100972035374692 16.942503085835487 18.451624664806545 19.030643673315407 19.055472141699337 23.207895053935278 25.071660045156847
         运行时间=221.794
         图分割的performance为: 25.071660045156847


3、谱聚类：(1) 都是分成两个子图的情况下，跟K-L算法的比较；
          (2) 固定划分子图的个数，让迭代次数增加，记录performance变化，画个图
          (3) 找到较优的迭代次数，让划分子图的次数从小变大，performance应该从小变大再变小
          结论：
          (1) 比K-L好，因为K-L固定两个子图大小一样，但是谱聚类不是
          (2) 迭代次数增加，performance可能先增加然后不变
          (3) performance应该从小变大再变小

          !!!!实验划分子图个数的时候，可以用Facebook的数据集

4、metis: (1)heavy VS random,结论：heavy容易产生不平衡的划分
          (2)random的随机种子，产生结果不一样
          (3)为了对抗这种不平衡的划分，谱聚类利用node的weight归一化
             归一化之后有所改善

4、hash：没什么好比较的，就说一下比其他算法差就好了
分区为2的时候：运行时间=1.128 performance为: 0.9088310711082526
              运行时间=1.249  performance为: 0.5066518381951788